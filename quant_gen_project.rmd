---
title: "Quantitative Genomics and Genetics 2018 Project"
author: "Darya Akimova"
date: "May 8, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r block1_packages, comment=NA, include=FALSE}
library(dplyr)  # for data manipulation
library(tidyr)  # for data manipulation
library(tibble)  # for data manipulation
library(broom)  # for cleaning up models
library(purrr)  # for applying functions
library(ggplot2)  # for plotting
library(cowplot)  # for plotting, modifies ggplot2 defaults
library(viridis)  # for color options
library(GGally)  # for plotting many variables together
library(HardyWeinberg)  # for Hardy-Weinberg equilibrium test
library(MASS)  # for access to matrix functions
# the package gaston is also loaded towards the end where it is used, so as not to interfere with other packages
```

```{r block2_functions, include = FALSE}
##### Functions for linear regression and statistical test with no covariates #####
MLE <- function(xa, xd, y_mat) {
  # calculates Beta_mu, Beta_a, and Beta_d - for linear regression, no covariates
  # required inputs: 1 column from x_a, 1 column from x_d, and 1 phenotype column
  #
  # used as a component of the lin_reg_p_val function
  
  X_mat <- cbind(1, xa, xd)
  beta_hat <- ginv(t(X_mat) %*% X_mat) %*% t(X_mat) %*% y_mat
  return(beta_hat)
}
fstat_calc <- function(xa, xd, MLE, y_mat) {
  # calculates f statistic based on estimated betas - for linear regression, no covariates
  # required inputs: 1 column from x_a, 1 column from x_d, MLE estimates from the MLE function, and 1 phenotype column
  #
  # used as a component of the lin_reg_p_val function
  
  X_mat <- cbind(1, xa, xd)
  y_hat <- X_mat %*% MLE
  SSM <- sum((y_hat - mean(y_mat)) ^ 2)
  SSE <- sum((y_mat - y_hat) ^ 2)
  df_M <- 2
  df_E <- length(xa) - 3
  Fstat <- (SSM / df_M) / (SSE / df_E)
  return(Fstat)
}
lin_reg_p_val <- function(xa, xd, gene) {
  # Applies the MLE and fstat_calc functions across the entire x_a and x_d data frames for 1 gene.
  # Used to reduce copy/paste of code
  # required inputs: the entire x_a dataframe/matrix, the entire x_d dataframe/matrix, and 1 phenotype column
  
  # Map the MLE function across the x_a and x_d objects, column by column. 
  # `gene` is the third input to the MLE function 
  mle_gene <- map2(data.frame(xa), data.frame(xd), MLE, gene)
  # Map the fstat_calc function across three arguments column by column for one gene/phenotype column:
  # 1) the entire x_a object
  # 2) the entire x_d object
  # 3) the calculated MLE estimates object 
  pval_gene <- pmap(
    list(
      xa = data.frame(xa), 
      xd = data.frame(xd), 
      MLE = mle_gene
      ), 
    fstat_calc, gene
    ) %>% 
    flatten_dbl() %>%  # simplify the results from a list
    pf(2, nrow(xa) - 3, lower.tail = FALSE)  # calculate the p-value   
  return(pval_gene)
}
##### Functions for linear regression and statistical test with covariates #####
lin_reg_fstat_w_covar <- function(xa, xd, gene, x_c = NULL) {
  # Performs a linear regression and calculates a p-value for when covariates are included in the model
  # Required inputs: 1 column from x_a, 1 column from x_d, 1 pheonypte column
  # Optional input: x_c, the matrix of covariates.
  # x_c can be left as NULL - will recapitulate p-values calculated through the MLE/fstat_calc functions above
  
  # create the X matrix for the null hypothesis - only a column of 1s and the covariate matrix are included
  X_mat_null <- cbind(matrix(1, nrow = length(xa), ncol = 1), x_c)
  # calculate the beta estimates for the null hypothesis (beta_mu and beta_z)
  beta_hat_null <- ginv(t(X_mat_null) %*% X_mat_null) %*% t(X_mat_null) %*% gene
  # create the X matrix for the alternative hypothesis - x_a and x_d included here
  X_mat_alt <- cbind(1, xa, xd, x_c)
  # calculate the beta estimates for the alternative hypothesis (beta_mu, beta_a, beta_d, and beta_z)
  beta_hat_alt <- ginv(t(X_mat_alt) %*% X_mat_alt) %*% t(X_mat_alt) %*% gene
  # predicted y (phenotype) under the null 
  y_hat_null <- X_mat_null %*% beta_hat_null
  # predicted y (phenotype) under the alternative
  y_hat_alt <- X_mat_alt %*% beta_hat_alt
  # SSE calculation
  SSE_null <- sum((gene - y_hat_null) ^ 2)
  SSE_alt <- sum((gene - y_hat_alt) ^ 2)
  # fstat calculation - alternative form to the fstat_calc function form
  fstat <- ((SSE_null - SSE_alt) / 2) / (SSE_alt / (nrow(geno) - 3))
  # p-vlue calculation
  pval <- pf(fstat, 2, length(xa) - 3, lower.tail = FALSE)
  return(pval)
}
```

```{r block3_data_import, comment=NA, include=FALSE}
# read in data
# geno = all provided genotype data
geno <- read.csv("QG18_genotypes.csv", row.names = 1)
# pheno = all provided phenotype data
pheno <- read.csv("QG18_phenotypes.csv", row.names = 1)
# covars = all information on covariates (Population/genetic background and Sex of individuals)
covars <- read.csv("QG18_covars.csv", row.names = 1, stringsAsFactors = FALSE)
# snp_info = information on all snps (chromosome and position)
snp_info <- read.csv("QG18_SNP_info.csv", stringsAsFactors = FALSE)
# gene_info = information on genes that the expression levels were measured as the phenotype
gene_info <- read.csv("QG18_gene_info.csv", stringsAsFactors = FALSE)
```

All of the provided data files were imported successfully and the quality of the data was accessed as follows to ensure that the data is in the expected format.

```{r block4_data_quality_checks, comment=NA}
# Are there any missing entries in the data?
anyNA(list(geno, pheno, covars, snp_info, gene_info))
# Are there approximately equal numbers of people in each covariate group? Is the design balanced?
table(covars$Population)
table(covars$Sex)
# Is the coding of the genotypes as expected across all of the data? Any unusual values?
table(as.matrix(geno))
# Are there any genotypes with a minor allele frequency below 5% that need to be removed?
geno_sums <- map_dbl(geno, function(x) sum(x) / (nrow(geno) * 2))
# Do any genotypes have a MAF < 5%
any(geno_sums < 0.05 | geno_sums > 0.95)
# Are there any genotypes without associated phenotypes, or vice versa?
all.equal(rownames(geno), rownames(pheno))
```

In summary, there were no missing values across all of the data and information files provided. There are approximately equal numbers of males and females in the study, and approximately equal numbers of individuals in each of the population groups. Most importantly, none of the covariate groups had a small n and the representation of groups is balanced. The genotype data were coded as expected, with no unusual values. All genotypes were found to have a minor allele frequency of greater than 5%, which indicates that no alleles at any genotype position were too rare for analysis. Lastly, all of the individuals in the genotype dataset are found in the phenotype dataset and no samples need to be filtered out on this criteria. 

Each of the gene expression levels included in the phenotype data were visualized below. In general, the expression level of each gene followed a normal distribution and no extreme outliers were found that needed to be excluded from analysis.

```{r block5_pheno_hist, echo=FALSE, comment=NA, fig.height=2, fig.width=8}
### prep of data for analysis ###
# change the phenotype names from probe to gene for easier interpretation and code readability
pheno_names <- pheno %>%
  rownames_to_column("sample") %>%  # preserve sample info through manipulation
  gather("gene", "abundance", 2:6) %>%  # change shape from wide to long for abundances
  # join on gene_info to connect probe to gene symbol (name)
  left_join(
    gene_info %>% 
      dplyr::select(probe, symbol), 
    by = c("gene" = "probe")) %>% 
  dplyr::select(-gene) %>%    # remove probe info
  spread("symbol", "abundance") %>%  # change shape from long to wide
  column_to_rownames("sample")  # return row names
pheno_names %>% 
  rownames_to_column("sample") %>% 
  gather("gene", "abundance", 2:6) %>% 
  ggplot(aes(x = abundance, fill = gene)) +
  geom_histogram(binwidth = 0.1) +
  facet_wrap(~ gene, nrow = 1) 
```

A principal component analysis (PCA) was performed on the phenotype data as an alternative means to determine if there are any outliers or an unusual structure. In brief, PCA is a useful method for multi-dimensional data, such as the case here with multiple phenotypes or genotypes per sample. Each principal component contains maximum shared information from the original observations in a step-wise fashion from each component to the next. Principal components can be plotted to reveal underlying structure in the data and also used for covariate modeling in later analysis. 

In the case of the phenotype data, the PCA analysis did not reveal any unusual patterns. Furthermore, none of the phenotype genes were found to be correlated with each other to a meaningful degree and, therefore, each one can be analyzed in a one by one pairing with each genotype. To visually investigate if the known population and sex covariates could have a potential relationship with the phenotypes, principal components from the phenotype PCA were plotted by various methods and colored based on the provided Population and Sex covaraites. These plots were not included in the final report, but the contents of code block 6 can be run in order to see the results. The plots did not suggest a relationship between either covariate. 

```{r block6_pheno_pca_and_additional_plots, include=FALSE, comment=NA}
# calculate PCA
pheno_pca <- prcomp(pheno_names)
# how much variance does each component explain? 
plot(
  (pheno_pca$sdev^2/ sum(pheno_pca$sdev^2)) * 100, 
  xlab = "Principal Component", 
  ylab = "Percent of total variance explained"
  )
# extract the component data
pheno_pca_x <- as.data.frame(pheno_pca$x)
# plot PC1 vs PC2 - color by covariates 
# is there any relationship of Phenotype to Population? 
pheno_pca_x %>% 
  # going the principal component results onto covariate information
  rownames_to_column("sample") %>% 
  left_join(
    covars %>% 
      rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Population)) +
  geom_point(size = 2, alpha = 0.8) +
  ggtitle("Principal Component Analysis of Phenotype Data\nColored by the Population Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")
# same plot as above, colored by Sex
pheno_pca_x %>% 
  rownames_to_column("sample") %>% 
  left_join(
    covars %>% 
      rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Sex)) +
  geom_point(size = 2, alpha = 0.8) +
  ggtitle("Principal Component Analysis of Phenotype Data\nColored by the Sex Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")
# do any of the phenotypes have a relationship with each other?
ggpairs(pheno_names)
# plot all 5 PC's and group by Sex - are there any patterns? 
ggpairs(
  pheno_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Sex)
  )
# plot all 5 PC's and group by Population - are there any patterns? 
ggpairs(
  pheno_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Population)
  )
```

Each SNP position was tested for Hardy-Weinberg Equilibrium using the exact test published by [Wigginton *et al* (2005)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1199378/). This is the same test that is performed by default by the Genome Association Analysis software PLINK. In this analysis, the test was used as implemented by the HardyWeinberg R package: [HardyWeinberg Package on CRAN](https://cran.r-project.org/package=HardyWeinberg). This test determined if the proportion of alleles at a particular genotype position were as expected. A statistically significant result can indicate a problem with the sequencing process or a population structure, both of which can result in misleading GWAS results.

```{r block7_HW_exact_test_at_each_snp, comment=NA, include=FALSE}
# implements the test for Hardy-Weinberg equilibrium at each SNP 
# the HWExact function requires a count of AA, AB, and BB as input
# each column of geno is converted to a factor with 3 levels for cases where no 0, 1, or 2 were measured at the SNP position
geno_exact_HW_test <- map(
  geno,  # map function over each column of geno data frame
  function(x) HWExact(table(factor(x, levels = c(0, 1, 2))), verbose = FALSE)
  )
# invert the list for easier access to p-values
geno_exact_HW_test_t <- purrr::transpose(geno_exact_HW_test)
# convert list of p-values for each SNP to a data frame that is easier to work with
geno_exact_HW_pval <- data.frame(unlist(geno_exact_HW_test_t$pval))
colnames(geno_exact_HW_pval) <- "pvalue"
geno_exact_HW_pval$position <- 1:nrow(geno_exact_HW_pval)
## Plot of the results ##
geno_exact_HW_pval %>% 
  ggplot(aes(x = pvalue)) +
  geom_histogram(bins = 50) +
  xlab("P-value") +
  ylab("Count") +
  ggtitle("Histogram of Hardy-Weinberg p-values\nOne test per each genotype position in the original data")
geno_exact_HW_pval %>% 
  ggplot(aes(x = position, y = -log(pvalue, base = 10))) +
  geom_point(size = 1, alpha = 0.5) +
  geom_hline(yintercept = -log(0.05, base = 10), color = "red", size = 1, alpha = 0.8) +
  geom_hline(yintercept = -log(0.05 / ncol(geno), base = 10), color = "blue", size = 1, alpha = 0.8) +
  ylab("-log(P-Value)") +
  xlab("Position") +
  ggtitle("Manhattan Plot of Hardy-Weinberg Equilibrium Exact Test Results\nRed Line = -log(P-value = 0.05)\nBlue Line = Bonferroni Cut-off of -log(P-value = 0.05 / 50,000)")
length(which(geno_exact_HW_pval < 0.05 / ncol(geno)))
length(which(geno_exact_HW_pval < 0.05))
```

It was found that 3,436 SNPs, out of the original 50,000, failed the Hardy-Weinberg Equilibrium test with a p-value < 0.05 cut-off. Code block 7 contains the entirety of the Hardy-Weinberg testing process, along with a histogram of the p-values for each SNP position and a Manhattan plot of the p-values, which indicated that SNPs that failed the test were scattered throughout the genome. All of these genotypes were removed from further analysis. 

PCA analysis was performed on the genotype, after filtering for SNPs that had failed the Hardy-Weinberg test, in order to determine if there was unusual structure in the genotype data that would need to be accounted for. PCA analysis on the genotype data was conducted in a number of ways: by analyzing the full genotype data, by analyzing a dataset where only every 10th genotype was included, and by an alternative method that is less computationally intensive. A number of plots were created in code block 8 in order to better understand these results, but only a matrix of plots will be included here. The key parts of the figure are the scatterplots below the diagonal, where the first 5 principal components was plotted against each other, colored by Population group.  

```{r block8_geno_filtered_on_HW_genes_plots_and_pca, comment=NA, include=FALSE}
# filter out genotypes that failed the HW equilibrium test:
geno_HW_filt <- geno[, which(geno_exact_HW_pval$pvalue >= 0.05)]
### PCA - full filtered genomics dataset
geno_HW_filt_pca <- prcomp(geno_HW_filt, center = TRUE, scale. = TRUE)
# plot variance explained by each principal component
plot(
  (geno_HW_filt_pca$sdev ^ 2/ sum(geno_HW_filt_pca$sdev ^ 2)) * 100, 
  xlab = "Principal Component", 
  ylab = "Percent of total variance explained",
  main = "Percent of total variance explained by each principal component")
geno_HW_filt_pca_x <- data.frame(geno_HW_filt_pca$x)
geno_HW_filt_pca_x %>% 
  rownames_to_column("sample") %>% 
  # join onto covariates data frame for covariate info for each sample
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Sex)) +
  geom_point(size = 2, alpha = 0.8) +
  ggtitle("Principal Component Analsysis\nColored by Sex Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")
geno_HW_filt_pca_x %>% 
  rownames_to_column("sample") %>% 
  # join onto covariates data frame for covariate info for each sample
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Population)) +
  geom_point(size = 2, alpha = 0.8) +
  ggtitle("Principal Component Analsysis\nColored by Population Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")

### alternative PCA method - PCA on individuals, but then take rotation ###
indv_HW_filt_pca <- prcomp(t(geno_HW_filt), center = TRUE, scale. = TRUE)
indv_HW_filt_pca_x <- as.data.frame(indv_HW_filt_pca$rotation) %>% 
  rownames_to_column("sample") %>% 
  left_join(covars %>% rownames_to_column("sample"), by = "sample")
indv_HW_filt_pca_x %>% 
  ggplot(aes(x = PC1, y = PC2, color = Population)) +
  geom_point(size = 2, alpha = 0.8)

### HW filtered genotype data, followed by taking every 10th genotype ###
geno_HW_filt_every10_pca <- prcomp(
  geno_HW_filt[, seq.int(from = 1, to = ncol(geno_HW_filt), by = 10)], 
  center = TRUE, scale. = TRUE
  )
# plot variance explained by each component
plot(
  (geno_HW_filt_every10_pca$sdev ^ 2/ sum(geno_HW_filt_every10_pca$sdev ^ 2)) * 100, 
  xlab = "Principal Component", 
  ylab = "Percent of total variance explained",
  main = "Percent of total variance explained by each principal component\nEvery 10th Genotype")
geno_HW_filt_every10_pca_x <- data.frame(geno_HW_filt_every10_pca$x)
geno_HW_filt_every10_pca_x %>% 
  rownames_to_column("sample") %>% 
  left_join(
    covars %>% 
      rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Sex)) +
  geom_point(size = 2, alpha = 0.8) +
  ggtitle("Principal Component Analsysis\nColored by Sex Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")
geno_HW_filt_every10_pca_x %>% 
  rownames_to_column("sample") %>% 
  left_join(
    covars %>% 
      rownames_to_column("sample"), 
    by = "sample"
    ) %>% 
  ggplot(aes(x = PC1, y = PC2, color = Population)) +
  geom_point(size = 2, alpha = 0.8)+
  ggtitle("Principal Component Analsysis\nColored by Population Covariate") +
  xlab("Principal Component 1") +
  ylab("Principal Component 2")
### Paired plots of the first 5 principal components 
### for both the full genotype data and the 10% filtered genotype data
# 10% filtered - Population grouping
ggpairs(
  geno_HW_filt_every10_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Population)
  )
# 10% filtered - Sex grouping
ggpairs(
  geno_HW_filt_every10_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Sex)
  )
# Full genoypte data - Sex grouping
ggpairs(
  geno_HW_filt_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Sex)
  )
```

```{r block8a_geno_pca_plot, comment=NA, echo = FALSE}
# Full genoypte data - Population grouping
ggpairs(
  geno_HW_filt_pca_x %>% 
    rownames_to_column("sample") %>% 
    left_join(
      covars %>% 
        rownames_to_column("sample"), 
      by = "sample"
      ),
  columns = 2:6,
  ggplot2::aes(colour = Population)
  )
```

 Interestingly, the principal component analysis suggests that the Sex covariate does not seem to play a significant role in the genotype structure. This makes sense since the genotype data does not include the sex chromosomes. The first principal component seems to carry most of the population-related variance, regardless of how the principal components are calculated. 

The first type of analysis that was conducted did not consider any covariates, either provided or derived from the PCA analysis. The genotype data that was used, was the set filtered on the Hardy-Weinberg Equilibrium test significant genes. 

```{r block9_gwas_simpl_lin_reg_no_covar, comment=NA, echo=FALSE}
# x_a matrix creation
x_a <- as.matrix(geno_HW_filt - 1)
# x_d matrix creation
x_d <- replace(
  as.matrix(geno_HW_filt), 
  which(as.matrix(geno_HW_filt) == 2 | as.matrix(geno_HW_filt) == 0), 
  -1
  )
### linear reg - F-stat based test and p-value calculation ###
# ERAP2
pval_ERAP2 <- lin_reg_p_val(x_a, x_d, pheno_names$ERAP2)
# FAHD1
pval_FAHD1 <- lin_reg_p_val(x_a, x_d, pheno_names$FAHD1)
# GFM1
pval_GFM1 <- lin_reg_p_val(x_a, x_d, pheno_names$GFM1)
# MARCH7
pval_MARCH7 <- lin_reg_p_val(x_a, x_d, pheno_names$MARCH7)
# PEX6
pval_PEX6 <- lin_reg_p_val(x_a, x_d, pheno_names$PEX6)
# combined data frame 
pval_no_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = pval_ERAP2,
    FAHD1 = pval_FAHD1,
    GFM1 = pval_GFM1,
    MARCH7 = pval_MARCH7,
    PEX6 = pval_PEX6
    )
  )
row.names(pval_no_covar) <- colnames(geno_HW_filt)
### p-value distribution ###
pval_no_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, color = gene, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Regression, no covariates\nAll Genes")
### Manhattan plot ###
pval_no_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nSimple Linear Regression, no covariates\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8) +
  ylim(0, 100)

### number of statistically significant positions after Bonferroni correction ###
pval_no_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < (0.05 / ncol(geno_HW_filt))) %>% 
  group_by(gene) %>% 
  count()

### ERAP2 hits SNP names and locations ###
no_covar_ERAP2_hits <- as.data.frame(
  row.names(pval_no_covar)[which(pval_no_covar$ERAP2 < 0.05 / ncol(geno_HW_filt))],
  stringsAsFactors = FALSE
  )
colnames(no_covar_ERAP2_hits) <- "id"
# join to SNP info dataset in order to get chromosome and position info
no_covar_ERAP2_hits <- no_covar_ERAP2_hits %>%
  left_join(snp_info, by = "id") %>% 
  arrange(chromosome, position) %>% 
  # is the SNP within the gene itself? Numbers from gene info file
  mutate(
    in_gene = position >= gene_info[which(gene_info$symbol == "ERAP2"), "start"] & position <= gene_info[which(gene_info$symbol == "ERAP2"), "end"]& chromosome == gene_info[which(gene_info$symbol == "ERAP2"), "chromosome"]
    )
# what percent of significant SNPs are within the gene coding region?
sum(no_covar_ERAP2_hits$in_gene) / nrow(no_covar_ERAP2_hits) * 100
# which chromosomes are the SNP hits located on?
unique(no_covar_ERAP2_hits$chromosome)
# what is the range of positions? 
summary(no_covar_ERAP2_hits$position)

### FAHD1 hits SNP names and locations #
no_covar_FAHD1_hits <- as.data.frame(
  row.names(pval_no_covar)[which(pval_no_covar$FAHD1 < 0.05 / ncol(geno_HW_filt))],
  stringsAsFactors = FALSE
  )
colnames(no_covar_FAHD1_hits) <- "id"
# join to SNP info dataset in order to get chromosome and position info
no_covar_FAHD1_hits <- no_covar_FAHD1_hits %>%
  left_join(snp_info, by = "id") %>% 
  arrange(chromosome, position) %>% 
  # is the SNP within the gene itself? Numbers from gene info file
  mutate(
    in_gene = position >= gene_info[which(gene_info$symbol == "FAHD1"), "start"] & position <= gene_info[which(gene_info$symbol == "FAHD1"), "end"] & chromosome == gene_info[which(gene_info$symbol == "FAHD1"), "chromosome"]
    )
# what percent of significant SNPs are within the gene coding region?
sum(no_covar_FAHD1_hits$in_gene) / nrow(no_covar_FAHD1_hits) * 100
# which chromosomes are the SNP hits located on?
unique(no_covar_FAHD1_hits$chromosome)
# what is the range of positions? 
summary(no_covar_FAHD1_hits$position)

### PEX6 hits SNP names and locations ###
no_covar_PEX6_hits <- as.data.frame(
  row.names(pval_no_covar)[which(pval_no_covar$PEX6 < 0.05 / ncol(geno_HW_filt))],
  stringsAsFactors = FALSE
  )
colnames(no_covar_PEX6_hits) <- "id"
# join to SNP info dataset in order to get chromosome and position info
no_covar_PEX6_hits <- no_covar_PEX6_hits %>%
  left_join(snp_info, by = "id") %>% 
  arrange(chromosome, position) %>% 
  # is the SNP within the gene itself? Numbers from gene info file
  mutate(
    in_gene = position >= gene_info[which(gene_info$symbol == "PEX6"), "start"] & position <= gene_info[which(gene_info$symbol == "PEX6"), "end"] & chromosome == gene_info[which(gene_info$symbol == "PEX6"), "chromosome"]
    )
# what percent of significant SNPs are within the gene coding region?
sum(no_covar_PEX6_hits$in_gene) / nrow(no_covar_PEX6_hits) * 100
# which chromosomes are the SNP hits located on?
unique(no_covar_PEX6_hits$chromosome)
# what is the range of positions? 
summary(no_covar_PEX6_hits$position[which(no_covar_PEX6_hits$chromosome == 6)])

### QQ Plot to assess data quality ###
pval_no_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_no_covar$x)))),
    ERAP2 = sort(-log10(pval_no_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_no_covar$FAHD1)),
    GFM1 = sort(-log10(pval_no_covar$GFM1)),
    MARCH7 = sort(-log10(pval_no_covar$MARCH7)),
    PEX6 = sort(-log10(pval_no_covar$PEX6))
    )
  )
pval_no_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nSimple Linear Regression, no Covariates\nAll Genes") +
  ylim(0, 100)
```

A number of SNPs were found to be associated with the expression levels of ERAP2, FAHD1, and PEX6. No SNPs were found to be associated with the expression of the GFM1 and MARCH 7 genes. The R code in Block 8 can be run in the notebook to explore all of the results. Based of the PCA analysis, it appears that the Population may be an important covariate to include in the models.

But first, let's test the relationship of each phenotype with each covariate:

```{r block10_pheno_covars_sig_tests, echo=FALSE, comment=NA}
## create a nested data frame for modeling
nested_pheno_w_given_covars <- pheno_names %>% 
  rownames_to_column("samples") %>% 
  left_join(
    covars %>% 
      rownames_to_column("samples"),
    by = "samples"
  ) %>% 
  gather("gene", "abundance", 2:6) %>% 
  nest(-gene)

## Do any of the phenotypes have a statistically significant relationship with the Population covariate 
# if it is coded with 4 levels: 1, 2, 3, 4 
num_factor_pop_lm <- nested_pheno_w_given_covars %>% 
  # model each phenotype as a function of numerically coded Population
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ as.numeric(factor(Population)), data = .)
      )
    ) %>% 
  # broom package used to simplify the structure of the lm function result
  mutate(glance_model = map(model, glance)) %>% 
  # unnest the above result
  unnest(glance_model) %>% 
  # select only the gene and the p-value for the significance of phenotype ~ covariate
  dplyr::select(gene, p.value)
num_factor_pop_lm[which(num_factor_pop_lm$p.value < 0.05), ]
# ERAP2 only

## What if Population was treated as a factor and R was allowed to code it
cat_factor_pop_lm <- nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
cat_factor_pop_lm[which(cat_factor_pop_lm$p.value < 0.05), ]
# ERAP2 only again

## Even though the PCA suggested that Sex does not contribute to structure in the data,
# Do any of the phenotypes have a statistically significant relationship with the Sex covarite?
covar_sex_lm <- nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Sex), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
any(covar_sex_lm < 0.05)
# none are significant on the sex covariable

## What about a combination of the two covariates? 
covars_sex_num_pop_lm <- nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ as.numeric(factor(Population)) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
covars_sex_num_pop_lm[which(covars_sex_num_pop_lm$p.value < 0.05), ]
# Only ERAP2 statistically significant again 
# If the result is cleaned using a different broom function,
# the estimates and associated p-values of each factor can be extracted
nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ as.numeric(factor(Population)) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(tidy_model = map(model, tidy)) %>% 
  unnest(tidy_model) %>% 
  filter(gene %in% covars_sex_num_pop_lm[which(covars_sex_num_pop_lm$p.value < 0.05), 1])
# Indicates that the relationship between population only is significant,
# even if both Population and Sex covariates are included in the model

## What is the result if R is allowed to code Population? 
covars_sex_cat_pop_lm <- nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
covars_sex_cat_pop_lm[which(covars_sex_cat_pop_lm$p.value < 0.05), ]
# ERAP2 only again
nested_pheno_w_given_covars %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(tidy_model = map(model, tidy)) %>% 
  unnest(tidy_model) %>% 
  filter(gene %in% covars_sex_num_pop_lm[which(covars_sex_num_pop_lm$p.value < 0.05), 1])
# Only significant on the TSI coding factor
# Again, Sex covariate does not seem important

##### Alternative Population coding of given covariate data #####
# PCA analysis suggested that the CEU population is very similar to GBR, what if its coded that way?
covars_mod <- covars 
# replace both "GBR" and "CEU" with "WEU" for generally western/northern european ancestry
covars_mod$Population <- replace(
  covars_mod$Population, 
  which(covars$Population == "GBR" | covars$Population == "CEU"), 
  "WEU"
  )
# new nested data frame with modified population coding
nested_pheno_w_covars_mod <- pheno_names %>% 
  rownames_to_column("samples") %>% 
  left_join(
    covars_mod %>% 
      rownames_to_column("samples"),
    by = "samples"
  ) %>% 
  gather("gene", "abundance", 2:6) %>% 
  nest(-gene)
# Do any of the phenotypes have a statistically significant relationship with the Population now?
covars_num_pop_weu_lm <- nested_pheno_w_covars_mod %>% 
  mutate(
    model = map(
      data, ~lm(abundance ~ as.numeric(factor(Population)), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
any(covars_num_pop_weu_lm$p.value < 0.05)
# None of the phenotypes have a statistically significant relationship with phenotype with the new coding

# What about if R was allowed to code the Population? 
covars_cat_pop_weu_lm <- nested_pheno_w_covars_mod %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
covars_cat_pop_weu_lm[which(covars_cat_pop_weu_lm$p.value < 0.05), ]
# only ERAP2 is statistically significant again 

# What if the Sex covaraite is included in this model? 
covars_sex_cat_pop_weu_lm <- nested_pheno_w_covars_mod %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
covars_sex_cat_pop_weu_lm[which(covars_sex_cat_pop_weu_lm$p.value < 0.05), ]
# Only ERAP2 again
nested_pheno_w_covars_mod %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ factor(Population) + factor(Sex), data = .)
      )
    ) %>% 
  mutate(tidy_model = map(model, tidy)) %>% 
  unnest(tidy_model) %>% 
  filter(gene %in% covars_sex_cat_pop_weu_lm[which(covars_sex_cat_pop_weu_lm$p.value < 0.05), 1])
```

Including Population as given as a covariate:

```{r block11_gwas_with_given_pop_covar, comment=NA, echo=FALSE}
pheno_with_covars <- pheno_names %>% 
  rownames_to_column("samples") %>% 
  left_join(
    covars %>% 
      rownames_to_column("samples"), 
    by = "samples")
x_c_pop <- as.numeric(factor(pheno_with_covars$Population))
### ERAP2 ###
pval_ERAP2_w_pop_num_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$ERAP2, x_c_pop
  ) %>% 
  flatten_dbl()
### FAHD1 ###
pval_FAHD1_w_pop_num_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$FAHD1, x_c_pop
  ) %>% 
  flatten_dbl()
### GFM1 ###
pval_GFM1_w_pop_num_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$GFM1, x_c_pop
  ) %>% 
  flatten_dbl()
### MARCH7 ###
pval_MARCH7_w_pop_num_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$MARCH7, x_c_pop
  ) %>% 
  flatten_dbl()
### PEX6 ###
pval_PEX6_w_pop_num_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$PEX6, x_c_pop
  ) %>% 
  flatten_dbl()

# combined data frame 
pval_num_pop_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = pval_ERAP2_w_pop_num_covar,
    FAHD1 = pval_FAHD1_w_pop_num_covar,
    GFM1 = pval_GFM1_w_pop_num_covar,
    MARCH7 = pval_MARCH7_w_pop_num_covar,
    PEX6 = pval_PEX6_w_pop_num_covar
    )
  )
row.names(pval_num_pop_covar) <- colnames(geno_HW_filt)
### p-value distribution ###
pval_num_pop_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Regression, Population included as covariate\nAll Genes")

### Manhattan plot ###
pval_num_pop_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nLinear Regression, Population included as covariate\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  ylim(0, 100) +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8)

### number of statistically significant positions after Bonferroni correction ###
pval_num_pop_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < 0.05 / ncol(geno_HW_filt)) %>% 
  group_by(gene) %>% 
  count()

### Comparison of hits: no covariates vs population as given covariate ###
# How do the ERAP2 hits compare when Population is included vs not included in the model? 
summary(which(pval_ERAP2_w_pop_num_covar < 0.05 / ncol(geno_HW_filt)))
summary(which(pval_ERAP2 < 0.05 / ncol(geno_HW_filt)))
# Are the hits the same as the analysis where Population is not included as a covariate?
all.equal(
  which(pval_ERAP2_w_pop_num_covar < 0.05 / ncol(geno_HW_filt)), 
  which(pval_ERAP2 < 0.05 / ncol(geno_HW_filt))
  )
# The hits are the same for ERAP2 between the two methods

# How do the FADH1 hits compare when Population is included vs not included in the model? 
all.equal(
  which(pval_FAHD1_w_pop_num_covar < 0.05 / ncol(geno_HW_filt)), 
  which(pval_FAHD1 < 0.05 / ncol(geno_HW_filt))
  )
# The FADH1 hits are also the same between the two methods

# There is 1 fewer PEX6 hit when Population is included in the model
num_pop_covar_PEX6_hits <- as.data.frame(
  row.names(pval_num_pop_covar)[which(pval_num_pop_covar$PEX6 < 0.05 / ncol(geno_HW_filt))],
  stringsAsFactors = FALSE
  )
colnames(num_pop_covar_PEX6_hits) <- "id"
# join to SNP info dataset in order to get chromosome and position info
num_pop_covar_PEX6_hits <- num_pop_covar_PEX6_hits %>%
  left_join(snp_info, by = "id") %>% 
  arrange(chromosome, position) %>% 
  mutate(
    in_gene = position >= gene_info[which(gene_info$symbol == "PEX6"), "start"] & position <= gene_info[which(gene_info$symbol == "PEX6"), "end"] & chromosome == gene_info[which(gene_info$symbol == "PEX6"), "chromosome"]
    )
# which chromosomes are the SNP hits located on?
unique(num_pop_covar_PEX6_hits$chromosome)
# the hit on chromosome 4 is still there
# which snp from the previous analysis is no longer a hit?
no_covar_PEX6_hits[which(!(no_covar_PEX6_hits$id %in% num_pop_covar_PEX6_hits$id)), ]

### QQ Plot to assess data quality ###
pval_num_pop_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_num_pop_covar$x)))),
    ERAP2 = sort(-log10(pval_num_pop_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_num_pop_covar$FAHD1)),
    GFM1 = sort(-log10(pval_num_pop_covar$GFM1)),
    MARCH7 = sort(-log10(pval_num_pop_covar$MARCH7)),
    PEX6 = sort(-log10(pval_num_pop_covar$PEX6))
    )
  )   
pval_num_pop_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, Population included as covariate\nAll Genes") +
  ylim(0, 100)
```

Try PC1 as a covariate: 

```{r block12_gwas_with_full_geno_PC1, comment=NA, echo=FALSE}
# join the phenotype data onto the full genotype (after HW filtering) PC components
pheno_with_geno_pca_x <- pheno_names %>% 
  rownames_to_column("samples") %>% 
  left_join(
    geno_HW_filt_pca_x %>% 
      rownames_to_column("samples"), 
    by = "samples")
# new covariate vector 
x_c_PC1 <- pheno_with_geno_pca_x$PC1
### Analysis with new covariate ###
### ERAP2 ###
pval_ERAP2_w_PC1_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$ERAP2, x_c_PC1
  ) %>% 
  flatten_dbl()
summary(which(pval_ERAP2_w_PC1_covar < 0.05 / ncol(geno_HW_filt)))
summary(which(pval_ERAP2 < 0.05 / ncol(geno_HW_filt)))
### FAHD1 ###
pval_FAHD1_w_PC1_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$FAHD1, x_c_PC1
  ) %>% 
  flatten_dbl()
### GFM1 ###
pval_GFM1_w_PC1_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$GFM1, x_c_PC1
  ) %>% 
  flatten_dbl()
### MARCH7 ###
pval_MARCH7_w_PC1_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$MARCH7, x_c_PC1
  ) %>% 
  flatten_dbl()
### PEX6 ###
pval_PEX6_w_PC1_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$PEX6, x_c_PC1
  ) %>% 
  flatten_dbl()

# combined data frame 
pval_PC1_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = pval_ERAP2_w_PC1_covar,
    FAHD1 = pval_FAHD1_w_PC1_covar,
    GFM1 = pval_GFM1_w_PC1_covar,
    MARCH7 = pval_MARCH7_w_PC1_covar,
    PEX6 = pval_PEX6_w_PC1_covar
    )
  )
row.names(pval_PC1_covar) <- colnames(geno_HW_filt)

### p-value distribution ###
pval_PC1_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Regression, PC1 from full genotype PCA included as covariate\nAll Genes")

### Manhattan plot ###
pval_PC1_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nLinear Regression, PC1 from full genotype PCA included as covariate\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  ylim(0, 100) +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8)

### number of statistically significant positions after Bonferroni correction ###
pval_PC1_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < 0.05 / ncol(geno_HW_filt)) %>% 
  group_by(gene) %>% 
  count()

# There is 1 more ERAP2 hit when PC1 is included in the model
# The QQ plot looks the same and has the same issues, so it's not worth interpreting

# There is an equal number of hits as with the previous two models for FAHD1 
# Are the hits the same for this third method?
all.equal(
  which(pval_FAHD1_w_PC1_covar < 0.05 / ncol(geno_HW_filt)), 
  which(pval_FAHD1 < 0.05 / ncol(geno_HW_filt))
  )
# The FADH1 hits are the same SNPs again

# There is an equal number of hits for this third analysis as for the previous one
# Are those hits the same?
all.equal(
  which(pval_PEX6_w_PC1_covar < 0.05 / ncol(geno_HW_filt)), 
  which(pval_PEX6_w_pop_num_covar < 0.05 / ncol(geno_HW_filt))
  )
# It is the same list of SNPs 

### QQ Plot ###
pval_PC1_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_PC1_covar$x)))),
    ERAP2 = sort(-log10(pval_PC1_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_PC1_covar$FAHD1)),
    GFM1 = sort(-log10(pval_PC1_covar$GFM1)),
    MARCH7 = sort(-log10(pval_PC1_covar$MARCH7)),
    PEX6 = sort(-log10(pval_PC1_covar$PEX6))
    )
  )   
pval_PC1_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1 from full genotype PCA included as covariate\nAll Genes") +
  ylim(0, 100)
```

So far, for each analysis, each gene was treated the same. What is the relationship of the expression level of each gene with the first few principal components? 

```{r block13_pheno_PC_sig_tests, echo=FALSE, comment=NA}
## create a nested data frame for modeling
nested_pheno_w_full_PC <- pheno_names %>% 
  rownames_to_column("samples") %>% 
  # join on geno first 10 PCs from genotype PCA analysis
  left_join(
    geno_HW_filt_pca_x %>% 
      dplyr::select(PC1:PC10) %>% 
      rownames_to_column("samples"),
    by = "samples"
  ) %>% 
  gather("gene", "abundance", 2:6) %>% 
  nest(-gene)
### Which of the phenotypes has a significant relationship with PC1? ###
full_geno_PC1_lm <- nested_pheno_w_full_PC %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ PC1, data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
# Which genes are significant?
full_geno_PC1_lm[which(full_geno_PC1_lm$p.value < 0.05), ]
# FAHD1 and PEX6
### What about PC2? ###
full_geno_PC2_lm <- nested_pheno_w_full_PC %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ PC2, data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
## Which genes have a significant relationship with PC2?
full_geno_PC2_lm[which(full_geno_PC2_lm$p.value < 0.05), ]
# ERAP2 
### PC3 ###
full_geno_PC3_lm <- nested_pheno_w_full_PC %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ PC3, data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
full_geno_PC3_lm[which(full_geno_PC3_lm$p.value < 0.05), ]
# ERAP2 and MARCH7
### PC4 ###
full_geno_PC4_lm <- nested_pheno_w_full_PC %>% 
  mutate(
    model = map(
      data, 
      ~lm(abundance ~ PC4, data = .)
      )
    ) %>% 
  mutate(glance_model = map(model, glance)) %>% 
  unnest(glance_model) %>% 
  dplyr::select(gene, p.value)
full_geno_PC4_lm[which(full_geno_PC4_lm$p.value < 0.05), ]
# FAHD1 has an extremely strong relationship with PC4
# which genotypes have the largest loadings onto PC4?
full_geno_PC4_load <- as.data.frame(geno_HW_filt_pca$rotation[, 4])
colnames(full_geno_PC4_load) <- "loading"
full_geno_PC4_load %>% 
  ggplot(aes(x = loading)) +
  geom_histogram(bins = 50)
top_PC4_loadings <- full_geno_PC4_load %>% 
  rownames_to_column("id") %>% 
  filter(loading > 0.04 | loading < -0.04) %>% 
  left_join(snp_info, by = "id") %>% 
  arrange(chromosome, position) %>% 
  mutate(
    in_gene = position >= gene_info[which(gene_info$symbol == "FAHD1"), "start"] & position <= gene_info[which(gene_info$symbol == "FAHD1"), "end"] & chromosome == gene_info[which(gene_info$symbol == "FAHD1"), "chromosome"]
    )
unique(top_PC4_loadings$chromosome)
summary(top_PC4_loadings$position)
# percent in gene?
sum(top_PC4_loadings$in_gene) / nrow(top_PC4_loadings) * 100
# what proportion of the top loading SNPs onto PC4 are hits from earlier tests?
sum(top_PC4_loadings$id %in% no_covar_FAHD1_hits$id) / nrow(no_covar_FAHD1_hits) * 100
# PC4 does not seem to have obvious population structure - including it may wipe out real hits?
```


```{r block14_gwas_with_full_geno_mixed_PC, comment=NA, echo=FALSE}
# PC1 - FAHD1 and PEX6
# PC2 - ERAP2
# PC3 - ERAP2 and MARCH7

### ERAP2 ###
# x_c - PC2 and PC3
x_c_ERAP2_cust_PC <- cbind(pheno_with_geno_pca_x$PC2, pheno_with_geno_pca_x$PC3)
pval_ERAP2_w_cust_PC_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$ERAP2, x_c_ERAP2_cust_PC
  ) %>% 
  flatten_dbl()
### FAHD1 ###
# x_c - PC1 (same as previous analsysis)
pval_FAHD1_w_cust_PC_covar <- pval_FAHD1_w_PC1_covar
### GFM1 ###
# no PC covariates
pval_GFM1_w_cust_PC_covar <- pval_GFM1
### MARCH7 ###
# x_c - PC3
x_c_MARCH7_cust_PC <- pheno_with_geno_pca_x$PC3
pval_MARCH7_w_cust_PC_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$MARCH7, x_c_MARCH7_cust_PC
  ) %>% 
  flatten_dbl()
### PEX6 ###
# x_c - PC1 (same as previous analsysis)
pval_PEX6_w_cust_PC_covar <- pval_PEX6_w_PC1_covar
  
# combined data frame
pval_cust_PC_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = pval_ERAP2_w_cust_PC_covar,
    FAHD1 = pval_FAHD1_w_cust_PC_covar,
    GFM1 = pval_GFM1_w_cust_PC_covar,
    MARCH7 = pval_MARCH7_w_cust_PC_covar,
    PEX6 = pval_PEX6_w_cust_PC_covar
    )
  )
row.names(pval_cust_PC_covar) <- colnames(geno_HW_filt)

### p-value distribution ###
pval_cust_PC_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Regression, mixed PCs from full genotype PCA included as covariate\nAll Genes")

### Manhattan plot ###
pval_cust_PC_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nLinear Regression, mixed PCs from full genotype PCA included as covariate\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  ylim(0, 100) +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8)

### number of statistically significant positions after Bonferroni correction ###
pval_cust_PC_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < 0.05 / ncol(geno_HW_filt)) %>% 
  group_by(gene) %>% 
  count()

### QQ Plot ###
pval_cust_PC_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_cust_PC_covar$x)))),
    ERAP2 = sort(-log10(pval_cust_PC_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_cust_PC_covar$FAHD1)),
    GFM1 = sort(-log10(pval_cust_PC_covar$GFM1)),
    MARCH7 = sort(-log10(pval_cust_PC_covar$MARCH7)),
    PEX6 = sort(-log10(pval_cust_PC_covar$PEX6))
    )
  )   
pval_cust_PC_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1 from full genotype PCA included as covariate\nAll Genes") +
  ylim(0, 100)
```



```{r block15_gwas_with_full_geno_PC1thruPC10, comment=NA, echo=FALSE}
# perhaps the correct approach is to just throw in more PCA components? 
# new covariate vector 
x_c_PC1_to_PC10 <- as.matrix(pheno_with_geno_pca_x[, 7:16])
### Analysis with new covariate ###
### ERAP2 ###
pval_ERAP2_w_PC1_to_PC10_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$ERAP2, x_c_PC1_to_PC10
  ) %>% 
  flatten_dbl()
### FAHD1 ###
pval_FAHD1_w_PC1_to_PC10_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$FAHD1, x_c_PC1_to_PC10
  ) %>% 
  flatten_dbl()
### GFM1 ###
pval_GFM1_w_PC1_to_PC10_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$GFM1, x_c_PC1_to_PC10
  ) %>% 
  flatten_dbl()
### MARCH7 ###
pval_MARCH7_w_PC1_to_PC10_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$MARCH7, x_c_PC1_to_PC10
  ) %>% 
  flatten_dbl()
### PEX6 ###
pval_PEX6_w_PC1_to_PC10_covar <- map2(
  data.frame(x_a), data.frame(x_d), 
  lin_reg_fstat_w_covar, 
  pheno_names$PEX6, x_c_PC1_to_PC10
  ) %>% 
  flatten_dbl()

# combined data frame 
pval_PC1_to_PC10_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = pval_ERAP2_w_PC1_to_PC10_covar,
    FAHD1 = pval_FAHD1_w_PC1_to_PC10_covar,
    GFM1 = pval_GFM1_w_PC1_to_PC10_covar,
    MARCH7 = pval_MARCH7_w_PC1_to_PC10_covar,
    PEX6 = pval_PEX6_w_PC1_to_PC10_covar
    )
  )
row.names(pval_PC1_to_PC10_covar) <- colnames(geno_HW_filt)

### p-value distribution ###
pval_PC1_to_PC10_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nAll Genes")

### Manhattan plot ###
pval_PC1_to_PC10_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  ylim(0, 100) +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8)

### number of statistically significant positions after Bonferroni correction ###
pval_PC1_to_PC10_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < 0.05 / ncol(geno_HW_filt)) %>% 
  group_by(gene) %>% 
  count()

### QQ Plot ###
pval_PC1_to_PC10_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_PC1_to_PC10_covar$x)))),
    ERAP2 = sort(-log10(pval_PC1_to_PC10_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_PC1_to_PC10_covar$FAHD1)),
    GFM1 = sort(-log10(pval_PC1_to_PC10_covar$GFM1)),
    MARCH7 = sort(-log10(pval_PC1_to_PC10_covar$MARCH7)),
    PEX6 = sort(-log10(pval_PC1_to_PC10_covar$PEX6))
    )
  )   
pval_PC1_to_PC10_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nAll Genes") +
  ylim(0, 100)
pval_PC1_to_PC10_covar_qqplot %>% 
  ggplot(aes(x = expected, y = FAHD1)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nFAHD1 Only")
pval_PC1_to_PC10_covar_qqplot %>% 
  ggplot(aes(x = expected, y = PEX6)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nPEX6 Only")
pval_PC1_to_PC10_covar_qqplot %>% 
  ggplot(aes(x = expected, y = ERAP2)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Regression, PC1-PC10 from full genotype PCA included as covariate\nERAP2 Only")
```



Including more principal components and covariates did not resolve the issues with the behavior of the p-values, as demonstrated by the QQ Plot. Perhaps it is best to try another modeling approach.

```{r block16_gaston_linear_mixed_model, comment=NA, eval = FALSE}
library(gaston)
geno_bed_matrix <- as(as.matrix(geno_HW_filt), "bed.matrix")
geno_A <- cov(t(geno_HW_filt))
pheno_test <- pheno_names$ERAP2
covariate_lmm <- as.matrix(base::cbind(rep(1, nrow(pheno)), pheno_with_geno_pca_x[, 7:9]))
### ERAP2 ###
lmm_ERAP2 <- association.test(
  x = geno_bed_matrix, Y = pheno_names$ERAP2, X = covariate_lmm,  
  method = "lmm", eigenK = eigen(geno_A), test = "lrt", response = "quantitative"
  )
### FAHD1 ###
lmm_FAHD1 <- association.test(
  x = geno_bed_matrix, Y = pheno_names$FAHD1, X = covariate_lmm,  
  method = "lmm", eigenK = eigen(geno_A), test = "lrt", response = "quantitative"
  )
### GFM1 ###
lmm_GFM1 <- association.test(
  x = geno_bed_matrix, Y = pheno_names$GFM1, X = covariate_lmm,  
  method = "lmm", eigenK = eigen(geno_A), test = "lrt", response = "quantitative"
  )
### MARCH7 ###
lmm_MARCH7 <- association.test(
  x = geno_bed_matrix, Y = pheno_names$MARCH7, X = covariate_lmm,  
  method = "lmm", eigenK = eigen(geno_A), test = "lrt", response = "quantitative"
  )
### PEX6 ###
lmm_PEX6 <- association.test(
  x = geno_bed_matrix, Y = pheno_names$PEX6, X = covariate_lmm,  
  method = "lmm", eigenK = eigen(geno_A), test = "lrt", response = "quantitative"
  )
### Combined data frame 
pval_lmm_PC1_to_PC3_covar <- as.data.frame(
  cbind(
    x = 1:ncol(geno_HW_filt), 
    ERAP2 = lmm_ERAP2$p,
    FAHD1 = lmm_FAHD1$p,
    GFM1 = lmm_GFM1$p,
    MARCH7 = lmm_MARCH7$p,
    PEX6 = lmm_PEX6$p
    )
  )
row.names(pval_lmm_PC1_to_PC3_covar) <- colnames(geno_HW_filt)
### p-value distribution ###
pval_lmm_PC1_to_PC3_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = pval, color = gene, fill = gene)) +
  geom_histogram(position = "identity", bins = 50) +
  facet_wrap(~ gene) +
  xlab("p-value") +
  ylab("Count") +
  ggtitle("Histogram of p-values\nLinear Mixed Model, PC1-PC3 as Covariates\nAll Genes")
### Manhattan plot ###
pval_lmm_PC1_to_PC3_covar %>% 
  gather("gene", "pval", 2:6) %>% 
  ggplot(aes(x = x, y = -log(pval, base = 10), color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  ggtitle("Manhattan Plot\nLinear Mixed Model, PC1-PC3 as Covariates\nAll Genes") +
  xlab("Genotype Position") +
  ylab("-log10(pValue)") +
  geom_hline(yintercept = -log(0.05 / ncol(geno_HW_filt), base = 10), size = 1, alpha = 0.8) +
  ylim(0, 100)

### number of statistically significant positions after Bonferroni correction ###
pval_lmm_PC1_to_PC3_covar %>% 
  rownames_to_column("snp") %>% 
  dplyr::select(-x) %>% 
  gather("gene", "pval", 2:6) %>% 
  filter(pval < (0.05 / ncol(geno_HW_filt))) %>% 
  group_by(gene) %>% 
  count()

### QQ Plot to assess data quality ###
pval_lmm_PC1_to_PC3_covar_qqplot <- data.frame(
  cbind(
    expected = sort(-log10(seq(from = 0,to = 1, length.out = length(pval_lmm_PC1_to_PC3_covar$x)))),
    ERAP2 = sort(-log10(pval_lmm_PC1_to_PC3_covar$ERAP2)),
    FAHD1 = sort(-log10(pval_lmm_PC1_to_PC3_covar$FAHD1)),
    GFM1 = sort(-log10(pval_lmm_PC1_to_PC3_covar$GFM1)),
    MARCH7 = sort(-log10(pval_lmm_PC1_to_PC3_covar$MARCH7)),
    PEX6 = sort(-log10(pval_lmm_PC1_to_PC3_covar$PEX6))
    )
  )
pval_lmm_PC1_to_PC3_covar_qqplot %>% 
  gather("gene", "neglog10_pval", 2:6) %>% 
  ggplot(aes(x = expected, y = neglog10_pval, color = gene)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "black", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Mixed Model, PC1-PC3 as Covariates\nAll Genes") +
  ylim(0, 100)
pval_lmm_PC1_to_PC3_covar_qqplot %>% 
  ggplot(aes(x = expected, y = FAHD1)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Mixed Model, PC1-PC3 as Covariates\nFAHD1 Only")
pval_lmm_PC1_to_PC3_covar_qqplot %>% 
  ggplot(aes(x = expected, y = PEX6)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Mixed Model, PC1-PC3 as Covariates\nPEX6 Only")
pval_lmm_PC1_to_PC3_covar_qqplot %>% 
  ggplot(aes(x = expected, y = ERAP2)) +
  geom_point(alpha = 0.8, size = 2) +
  geom_abline(intercept = 0, slope = 1, col = "red", alpha = 0.5, size = 2) +
  xlab("Expected -log(pValue)") +
  ylab("Observed -log(pValue)") +
  ggtitle("QQ Plot\nLinear Mixed Model, PC1-PC3 as Covariates\nERAP2 Only")
```


```{r block17_extra_plots, include=FALSE}
# histogram of phenotypes, broken up by population 
pheno %>% 
  rownames_to_column("sample") %>% 
  gather("probe", "abundance", 2:6) %>% 
  left_join(gene_info, by = "probe") %>% 
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample") %>% 
  ggplot(aes(x = abundance, fill = Population)) +
  geom_histogram(binwidth = 0.1, alpha = 0.8, position = "identity") +
  facet_grid(Population ~ symbol) +
  xlab("Gene Abundance") +
  ylab("Count")
# histogram of phenotypes, broken up by sex covariate
pheno %>% 
  rownames_to_column("sample") %>% 
  gather("probe", "abundance", 2:6) %>% 
  left_join(gene_info, by = "probe") %>% 
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample") %>% 
  ggplot(aes(x = abundance, fill = Sex)) +
  geom_histogram(binwidth = 0.1, alpha = 0.8, position = "identity") +
  facet_grid(Sex ~ symbol) +
  xlab("Gene Abundance") +
  ylab("Count")
# Box plots of phenotype abundances, broken up by sex covariate
pheno %>% 
  rownames_to_column("sample") %>% 
  gather("probe", "abundance", 2:6) %>% 
  left_join(gene_info, by = "probe") %>% 
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample") %>% 
  ggplot(aes(x = Sex, y = abundance, fill = Sex)) +
  geom_boxplot() +
  facet_wrap(~ symbol) +
  ylab("Abundance") +
  xlab("Sex Grouping")
# box plots of phenotype abundances, broken up by population covariates
pheno %>% 
  rownames_to_column("sample") %>% 
  gather("probe", "abundance", 2:6) %>% 
  left_join(gene_info, by = "probe") %>% 
  left_join(
    covars %>% rownames_to_column("sample"), 
    by = "sample") %>% 
  ggplot(aes(x = Population, y = abundance, fill = Population)) +
  geom_boxplot() +
  facet_wrap(~ symbol) +
  ylab("Abundance") +
  xlab("Population Grouping")
```
